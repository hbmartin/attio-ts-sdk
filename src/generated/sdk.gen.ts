// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client';
import { client } from './client.gen';
import type { DeleteV2CommentsByCommentIdData, DeleteV2CommentsByCommentIdErrors, DeleteV2CommentsByCommentIdResponses, DeleteV2ListsByListEntriesByEntryIdData, DeleteV2ListsByListEntriesByEntryIdErrors, DeleteV2ListsByListEntriesByEntryIdResponses, DeleteV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdData, DeleteV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdErrors, DeleteV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdResponses, DeleteV2NotesByNoteIdData, DeleteV2NotesByNoteIdErrors, DeleteV2NotesByNoteIdResponses, DeleteV2ObjectsByObjectRecordsByRecordIdData, DeleteV2ObjectsByObjectRecordsByRecordIdErrors, DeleteV2ObjectsByObjectRecordsByRecordIdResponses, DeleteV2TasksByTaskIdData, DeleteV2TasksByTaskIdErrors, DeleteV2TasksByTaskIdResponses, DeleteV2WebhooksByWebhookIdData, DeleteV2WebhooksByWebhookIdErrors, DeleteV2WebhooksByWebhookIdResponses, GetScimV2SchemasData, GetScimV2SchemasResponses, GetV2ByTargetByIdentifierAttributesByAttributeData, GetV2ByTargetByIdentifierAttributesByAttributeErrors, GetV2ByTargetByIdentifierAttributesByAttributeOptionsData, GetV2ByTargetByIdentifierAttributesByAttributeOptionsErrors, GetV2ByTargetByIdentifierAttributesByAttributeOptionsResponses, GetV2ByTargetByIdentifierAttributesByAttributeResponses, GetV2ByTargetByIdentifierAttributesByAttributeStatusesData, GetV2ByTargetByIdentifierAttributesByAttributeStatusesErrors, GetV2ByTargetByIdentifierAttributesByAttributeStatusesResponses, GetV2ByTargetByIdentifierAttributesData, GetV2ByTargetByIdentifierAttributesResponses, GetV2CommentsByCommentIdData, GetV2CommentsByCommentIdErrors, GetV2CommentsByCommentIdResponses, GetV2ListsByListData, GetV2ListsByListEntriesByEntryIdAttributesByAttributeValuesData, GetV2ListsByListEntriesByEntryIdAttributesByAttributeValuesErrors, GetV2ListsByListEntriesByEntryIdAttributesByAttributeValuesResponses, GetV2ListsByListEntriesByEntryIdData, GetV2ListsByListEntriesByEntryIdErrors, GetV2ListsByListEntriesByEntryIdResponses, GetV2ListsByListErrors, GetV2ListsByListResponses, GetV2ListsData, GetV2ListsResponses, GetV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdData, GetV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdErrors, GetV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdResponses, GetV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdTranscriptData, GetV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdTranscriptResponses, GetV2MeetingsByMeetingIdCallRecordingsData, GetV2MeetingsByMeetingIdCallRecordingsResponses, GetV2MeetingsByMeetingIdData, GetV2MeetingsByMeetingIdErrors, GetV2MeetingsByMeetingIdResponses, GetV2MeetingsData, GetV2MeetingsResponses, GetV2NotesByNoteIdData, GetV2NotesByNoteIdErrors, GetV2NotesByNoteIdResponses, GetV2NotesData, GetV2NotesErrors, GetV2NotesResponses, GetV2ObjectsByObjectData, GetV2ObjectsByObjectErrors, GetV2ObjectsByObjectRecordsByRecordIdAttributesByAttributeValuesData, GetV2ObjectsByObjectRecordsByRecordIdAttributesByAttributeValuesErrors, GetV2ObjectsByObjectRecordsByRecordIdAttributesByAttributeValuesResponses, GetV2ObjectsByObjectRecordsByRecordIdData, GetV2ObjectsByObjectRecordsByRecordIdEntriesData, GetV2ObjectsByObjectRecordsByRecordIdEntriesResponses, GetV2ObjectsByObjectRecordsByRecordIdErrors, GetV2ObjectsByObjectRecordsByRecordIdResponses, GetV2ObjectsByObjectResponses, GetV2ObjectsData, GetV2ObjectsResponses, GetV2SelfData, GetV2SelfResponses, GetV2TasksByTaskIdData, GetV2TasksByTaskIdErrors, GetV2TasksByTaskIdResponses, GetV2TasksData, GetV2TasksResponses, GetV2ThreadsByThreadIdData, GetV2ThreadsByThreadIdErrors, GetV2ThreadsByThreadIdResponses, GetV2ThreadsData, GetV2ThreadsResponses, GetV2WebhooksByWebhookIdData, GetV2WebhooksByWebhookIdErrors, GetV2WebhooksByWebhookIdResponses, GetV2WebhooksData, GetV2WebhooksResponses, GetV2WorkspaceMembersByWorkspaceMemberIdData, GetV2WorkspaceMembersByWorkspaceMemberIdErrors, GetV2WorkspaceMembersByWorkspaceMemberIdResponses, GetV2WorkspaceMembersData, GetV2WorkspaceMembersResponses, PatchV2ByTargetByIdentifierAttributesByAttributeData, PatchV2ByTargetByIdentifierAttributesByAttributeErrors, PatchV2ByTargetByIdentifierAttributesByAttributeOptionsByOptionData, PatchV2ByTargetByIdentifierAttributesByAttributeOptionsByOptionErrors, PatchV2ByTargetByIdentifierAttributesByAttributeOptionsByOptionResponses, PatchV2ByTargetByIdentifierAttributesByAttributeResponses, PatchV2ByTargetByIdentifierAttributesByAttributeStatusesByStatusData, PatchV2ByTargetByIdentifierAttributesByAttributeStatusesByStatusErrors, PatchV2ByTargetByIdentifierAttributesByAttributeStatusesByStatusResponses, PatchV2ListsByListData, PatchV2ListsByListEntriesByEntryIdData, PatchV2ListsByListEntriesByEntryIdErrors, PatchV2ListsByListEntriesByEntryIdResponses, PatchV2ListsByListErrors, PatchV2ListsByListResponses, PatchV2ObjectsByObjectData, PatchV2ObjectsByObjectErrors, PatchV2ObjectsByObjectRecordsByRecordIdData, PatchV2ObjectsByObjectRecordsByRecordIdErrors, PatchV2ObjectsByObjectRecordsByRecordIdResponses, PatchV2ObjectsByObjectResponses, PatchV2TasksByTaskIdData, PatchV2TasksByTaskIdErrors, PatchV2TasksByTaskIdResponses, PatchV2WebhooksByWebhookIdData, PatchV2WebhooksByWebhookIdErrors, PatchV2WebhooksByWebhookIdResponses, PostV2ByTargetByIdentifierAttributesByAttributeOptionsData, PostV2ByTargetByIdentifierAttributesByAttributeOptionsErrors, PostV2ByTargetByIdentifierAttributesByAttributeOptionsResponses, PostV2ByTargetByIdentifierAttributesByAttributeStatusesData, PostV2ByTargetByIdentifierAttributesByAttributeStatusesErrors, PostV2ByTargetByIdentifierAttributesByAttributeStatusesResponses, PostV2ByTargetByIdentifierAttributesData, PostV2ByTargetByIdentifierAttributesErrors, PostV2ByTargetByIdentifierAttributesResponses, PostV2CommentsData, PostV2CommentsErrors, PostV2CommentsResponses, PostV2ListsByListEntriesData, PostV2ListsByListEntriesErrors, PostV2ListsByListEntriesQueryData, PostV2ListsByListEntriesQueryErrors, PostV2ListsByListEntriesQueryResponses, PostV2ListsByListEntriesResponses, PostV2ListsData, PostV2ListsErrors, PostV2ListsResponses, PostV2MeetingsByMeetingIdCallRecordingsData, PostV2MeetingsByMeetingIdCallRecordingsErrors, PostV2MeetingsByMeetingIdCallRecordingsResponses, PostV2MeetingsData, PostV2MeetingsErrors, PostV2MeetingsResponses, PostV2NotesData, PostV2NotesErrors, PostV2NotesResponses, PostV2ObjectsByObjectRecordsData, PostV2ObjectsByObjectRecordsErrors, PostV2ObjectsByObjectRecordsQueryData, PostV2ObjectsByObjectRecordsQueryErrors, PostV2ObjectsByObjectRecordsQueryResponses, PostV2ObjectsByObjectRecordsResponses, PostV2ObjectsData, PostV2ObjectsErrors, PostV2ObjectsRecordsSearchData, PostV2ObjectsRecordsSearchErrors, PostV2ObjectsRecordsSearchResponses, PostV2ObjectsResponses, PostV2TasksData, PostV2TasksErrors, PostV2TasksResponses, PostV2WebhooksData, PostV2WebhooksErrors, PostV2WebhooksResponses, PutV2ListsByListEntriesByEntryIdData, PutV2ListsByListEntriesByEntryIdErrors, PutV2ListsByListEntriesByEntryIdResponses, PutV2ListsByListEntriesData, PutV2ListsByListEntriesErrors, PutV2ListsByListEntriesResponses, PutV2ObjectsByObjectRecordsByRecordIdData, PutV2ObjectsByObjectRecordsByRecordIdErrors, PutV2ObjectsByObjectRecordsByRecordIdResponses, PutV2ObjectsByObjectRecordsData, PutV2ObjectsByObjectRecordsErrors, PutV2ObjectsByObjectRecordsResponses } from './types.gen';
import { zDeleteV2CommentsByCommentIdData, zDeleteV2CommentsByCommentIdResponse, zDeleteV2ListsByListEntriesByEntryIdData, zDeleteV2ListsByListEntriesByEntryIdResponse, zDeleteV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdData, zDeleteV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdResponse, zDeleteV2NotesByNoteIdData, zDeleteV2NotesByNoteIdResponse, zDeleteV2ObjectsByObjectRecordsByRecordIdData, zDeleteV2ObjectsByObjectRecordsByRecordIdResponse, zDeleteV2TasksByTaskIdData, zDeleteV2TasksByTaskIdResponse, zDeleteV2WebhooksByWebhookIdData, zDeleteV2WebhooksByWebhookIdResponse, zGetScimV2SchemasData, zGetScimV2SchemasResponse, zGetV2ByTargetByIdentifierAttributesByAttributeData, zGetV2ByTargetByIdentifierAttributesByAttributeOptionsData, zGetV2ByTargetByIdentifierAttributesByAttributeOptionsResponse, zGetV2ByTargetByIdentifierAttributesByAttributeResponse, zGetV2ByTargetByIdentifierAttributesByAttributeStatusesData, zGetV2ByTargetByIdentifierAttributesByAttributeStatusesResponse, zGetV2ByTargetByIdentifierAttributesData, zGetV2ByTargetByIdentifierAttributesResponse, zGetV2CommentsByCommentIdData, zGetV2CommentsByCommentIdResponse, zGetV2ListsByListData, zGetV2ListsByListEntriesByEntryIdAttributesByAttributeValuesData, zGetV2ListsByListEntriesByEntryIdAttributesByAttributeValuesResponse, zGetV2ListsByListEntriesByEntryIdData, zGetV2ListsByListEntriesByEntryIdResponse, zGetV2ListsByListResponse, zGetV2ListsData, zGetV2ListsResponse, zGetV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdData, zGetV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdResponse, zGetV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdTranscriptData, zGetV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdTranscriptResponse, zGetV2MeetingsByMeetingIdCallRecordingsData, zGetV2MeetingsByMeetingIdCallRecordingsResponse, zGetV2MeetingsByMeetingIdData, zGetV2MeetingsByMeetingIdResponse, zGetV2MeetingsData, zGetV2MeetingsResponse, zGetV2NotesByNoteIdData, zGetV2NotesByNoteIdResponse, zGetV2NotesData, zGetV2NotesResponse, zGetV2ObjectsByObjectData, zGetV2ObjectsByObjectRecordsByRecordIdAttributesByAttributeValuesData, zGetV2ObjectsByObjectRecordsByRecordIdAttributesByAttributeValuesResponse, zGetV2ObjectsByObjectRecordsByRecordIdData, zGetV2ObjectsByObjectRecordsByRecordIdEntriesData, zGetV2ObjectsByObjectRecordsByRecordIdEntriesResponse, zGetV2ObjectsByObjectRecordsByRecordIdResponse, zGetV2ObjectsByObjectResponse, zGetV2ObjectsData, zGetV2ObjectsResponse, zGetV2SelfData, zGetV2SelfResponse, zGetV2TasksByTaskIdData, zGetV2TasksByTaskIdResponse, zGetV2TasksData, zGetV2TasksResponse, zGetV2ThreadsByThreadIdData, zGetV2ThreadsByThreadIdResponse, zGetV2ThreadsData, zGetV2ThreadsResponse, zGetV2WebhooksByWebhookIdData, zGetV2WebhooksByWebhookIdResponse, zGetV2WebhooksData, zGetV2WebhooksResponse, zGetV2WorkspaceMembersByWorkspaceMemberIdData, zGetV2WorkspaceMembersByWorkspaceMemberIdResponse, zGetV2WorkspaceMembersData, zGetV2WorkspaceMembersResponse, zPatchV2ByTargetByIdentifierAttributesByAttributeData, zPatchV2ByTargetByIdentifierAttributesByAttributeOptionsByOptionData, zPatchV2ByTargetByIdentifierAttributesByAttributeOptionsByOptionResponse, zPatchV2ByTargetByIdentifierAttributesByAttributeResponse, zPatchV2ByTargetByIdentifierAttributesByAttributeStatusesByStatusData, zPatchV2ByTargetByIdentifierAttributesByAttributeStatusesByStatusResponse, zPatchV2ListsByListData, zPatchV2ListsByListEntriesByEntryIdData, zPatchV2ListsByListEntriesByEntryIdResponse, zPatchV2ListsByListResponse, zPatchV2ObjectsByObjectData, zPatchV2ObjectsByObjectRecordsByRecordIdData, zPatchV2ObjectsByObjectRecordsByRecordIdResponse, zPatchV2ObjectsByObjectResponse, zPatchV2TasksByTaskIdData, zPatchV2TasksByTaskIdResponse, zPatchV2WebhooksByWebhookIdData, zPatchV2WebhooksByWebhookIdResponse, zPostV2ByTargetByIdentifierAttributesByAttributeOptionsData, zPostV2ByTargetByIdentifierAttributesByAttributeOptionsResponse, zPostV2ByTargetByIdentifierAttributesByAttributeStatusesData, zPostV2ByTargetByIdentifierAttributesByAttributeStatusesResponse, zPostV2ByTargetByIdentifierAttributesData, zPostV2ByTargetByIdentifierAttributesResponse, zPostV2CommentsData, zPostV2CommentsResponse, zPostV2ListsByListEntriesData, zPostV2ListsByListEntriesQueryData, zPostV2ListsByListEntriesQueryResponse, zPostV2ListsByListEntriesResponse, zPostV2ListsData, zPostV2ListsResponse, zPostV2MeetingsByMeetingIdCallRecordingsData, zPostV2MeetingsByMeetingIdCallRecordingsResponse, zPostV2MeetingsData, zPostV2MeetingsResponse, zPostV2NotesData, zPostV2NotesResponse, zPostV2ObjectsByObjectRecordsData, zPostV2ObjectsByObjectRecordsQueryData, zPostV2ObjectsByObjectRecordsQueryResponse, zPostV2ObjectsByObjectRecordsResponse, zPostV2ObjectsData, zPostV2ObjectsRecordsSearchData, zPostV2ObjectsRecordsSearchResponse, zPostV2ObjectsResponse, zPostV2TasksData, zPostV2TasksResponse, zPostV2WebhooksData, zPostV2WebhooksResponse, zPutV2ListsByListEntriesByEntryIdData, zPutV2ListsByListEntriesByEntryIdResponse, zPutV2ListsByListEntriesData, zPutV2ListsByListEntriesResponse, zPutV2ObjectsByObjectRecordsByRecordIdData, zPutV2ObjectsByObjectRecordsByRecordIdResponse, zPutV2ObjectsByObjectRecordsData, zPutV2ObjectsByObjectRecordsResponse } from './zod.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * List objects
 *
 * Lists all system-defined and user-defined objects in your workspace.
 *
 * Required scopes: `object_configuration:read`.
 */
export const getV2Objects = <ThrowOnError extends boolean = false>(options?: Options<GetV2ObjectsData, ThrowOnError>) => (options?.client ?? client).get<GetV2ObjectsResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGetV2ObjectsData.parseAsync(data),
    responseValidator: async (data) => await zGetV2ObjectsResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/objects',
    ...options
});

/**
 * Create an object
 *
 * Creates a new custom object in your workspace.
 *
 * Required scopes: `object_configuration:read-write`.
 */
export const postV2Objects = <ThrowOnError extends boolean = false>(options: Options<PostV2ObjectsData, ThrowOnError>) => (options.client ?? client).post<PostV2ObjectsResponses, PostV2ObjectsErrors, ThrowOnError>({
    requestValidator: async (data) => await zPostV2ObjectsData.parseAsync(data),
    responseValidator: async (data) => await zPostV2ObjectsResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/objects',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get an object
 *
 * Gets a single object by its `object_id` or slug.
 *
 * Required scopes: `object_configuration:read`.
 */
export const getV2ObjectsByObject = <ThrowOnError extends boolean = false>(options: Options<GetV2ObjectsByObjectData, ThrowOnError>) => (options.client ?? client).get<GetV2ObjectsByObjectResponses, GetV2ObjectsByObjectErrors, ThrowOnError>({
    requestValidator: async (data) => await zGetV2ObjectsByObjectData.parseAsync(data),
    responseValidator: async (data) => await zGetV2ObjectsByObjectResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/objects/{object}',
    ...options
});

/**
 * Update an object
 *
 * Updates a single object. The object to be updated is identified by its `object_id`.
 *
 * Required scopes: `object_configuration:read-write`.
 */
export const patchV2ObjectsByObject = <ThrowOnError extends boolean = false>(options: Options<PatchV2ObjectsByObjectData, ThrowOnError>) => (options.client ?? client).patch<PatchV2ObjectsByObjectResponses, PatchV2ObjectsByObjectErrors, ThrowOnError>({
    requestValidator: async (data) => await zPatchV2ObjectsByObjectData.parseAsync(data),
    responseValidator: async (data) => await zPatchV2ObjectsByObjectResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/objects/{object}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List attributes
 *
 * Lists all attributes defined on a specific object or list. Attributes are returned in the order that they are sorted by in the UI.
 *
 * Required scopes: `object_configuration:read`.
 */
export const getV2ByTargetByIdentifierAttributes = <ThrowOnError extends boolean = false>(options: Options<GetV2ByTargetByIdentifierAttributesData, ThrowOnError>) => (options.client ?? client).get<GetV2ByTargetByIdentifierAttributesResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGetV2ByTargetByIdentifierAttributesData.parseAsync(data),
    responseValidator: async (data) => await zGetV2ByTargetByIdentifierAttributesResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/{target}/{identifier}/attributes',
    ...options
});

/**
 * Create an attribute
 *
 * Creates a new attribute on either an object or a list.
 *
 * For record-reference attributes, you can optionally create a bidirectional relationship by providing a `relationship` object. This will create two entangled attributes: one on the specified object and a reverse attribute on the related object.
 *
 * To create an attribute on an object, you must also have the `object_configuration:read-write` scope.
 *
 * To create an attribute on a list, you must also have the `list_configuration:read-write` scope.
 */
export const postV2ByTargetByIdentifierAttributes = <ThrowOnError extends boolean = false>(options: Options<PostV2ByTargetByIdentifierAttributesData, ThrowOnError>) => (options.client ?? client).post<PostV2ByTargetByIdentifierAttributesResponses, PostV2ByTargetByIdentifierAttributesErrors, ThrowOnError>({
    requestValidator: async (data) => await zPostV2ByTargetByIdentifierAttributesData.parseAsync(data),
    responseValidator: async (data) => await zPostV2ByTargetByIdentifierAttributesResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/{target}/{identifier}/attributes',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get an attribute
 *
 * Gets information about a single attribute on either an object or a list.
 *
 * Required scopes: `object_configuration:read`.
 */
export const getV2ByTargetByIdentifierAttributesByAttribute = <ThrowOnError extends boolean = false>(options: Options<GetV2ByTargetByIdentifierAttributesByAttributeData, ThrowOnError>) => (options.client ?? client).get<GetV2ByTargetByIdentifierAttributesByAttributeResponses, GetV2ByTargetByIdentifierAttributesByAttributeErrors, ThrowOnError>({
    requestValidator: async (data) => await zGetV2ByTargetByIdentifierAttributesByAttributeData.parseAsync(data),
    responseValidator: async (data) => await zGetV2ByTargetByIdentifierAttributesByAttributeResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/{target}/{identifier}/attributes/{attribute}',
    ...options
});

/**
 * Update an attribute
 *
 * Updates a single attribute on a given object or list.
 *
 * Required scopes: `object_configuration:read-write`.
 */
export const patchV2ByTargetByIdentifierAttributesByAttribute = <ThrowOnError extends boolean = false>(options: Options<PatchV2ByTargetByIdentifierAttributesByAttributeData, ThrowOnError>) => (options.client ?? client).patch<PatchV2ByTargetByIdentifierAttributesByAttributeResponses, PatchV2ByTargetByIdentifierAttributesByAttributeErrors, ThrowOnError>({
    requestValidator: async (data) => await zPatchV2ByTargetByIdentifierAttributesByAttributeData.parseAsync(data),
    responseValidator: async (data) => await zPatchV2ByTargetByIdentifierAttributesByAttributeResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/{target}/{identifier}/attributes/{attribute}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List select options
 *
 * Lists all select options for a particular attribute on either an object or a list.
 *
 * Required scopes: `object_configuration:read`.
 */
export const getV2ByTargetByIdentifierAttributesByAttributeOptions = <ThrowOnError extends boolean = false>(options: Options<GetV2ByTargetByIdentifierAttributesByAttributeOptionsData, ThrowOnError>) => (options.client ?? client).get<GetV2ByTargetByIdentifierAttributesByAttributeOptionsResponses, GetV2ByTargetByIdentifierAttributesByAttributeOptionsErrors, ThrowOnError>({
    requestValidator: async (data) => await zGetV2ByTargetByIdentifierAttributesByAttributeOptionsData.parseAsync(data),
    responseValidator: async (data) => await zGetV2ByTargetByIdentifierAttributesByAttributeOptionsResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/{target}/{identifier}/attributes/{attribute}/options',
    ...options
});

/**
 * Create a select option
 *
 * Adds a select option to a select attribute on an object or a list.
 *
 * Required scopes: `object_configuration:read-write`.
 */
export const postV2ByTargetByIdentifierAttributesByAttributeOptions = <ThrowOnError extends boolean = false>(options: Options<PostV2ByTargetByIdentifierAttributesByAttributeOptionsData, ThrowOnError>) => (options.client ?? client).post<PostV2ByTargetByIdentifierAttributesByAttributeOptionsResponses, PostV2ByTargetByIdentifierAttributesByAttributeOptionsErrors, ThrowOnError>({
    requestValidator: async (data) => await zPostV2ByTargetByIdentifierAttributesByAttributeOptionsData.parseAsync(data),
    responseValidator: async (data) => await zPostV2ByTargetByIdentifierAttributesByAttributeOptionsResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/{target}/{identifier}/attributes/{attribute}/options',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Update a select option
 *
 * Updates a select option on an attribute on either an object or a list.
 *
 * Required scopes: `object_configuration:read-write`.
 */
export const patchV2ByTargetByIdentifierAttributesByAttributeOptionsByOption = <ThrowOnError extends boolean = false>(options: Options<PatchV2ByTargetByIdentifierAttributesByAttributeOptionsByOptionData, ThrowOnError>) => (options.client ?? client).patch<PatchV2ByTargetByIdentifierAttributesByAttributeOptionsByOptionResponses, PatchV2ByTargetByIdentifierAttributesByAttributeOptionsByOptionErrors, ThrowOnError>({
    requestValidator: async (data) => await zPatchV2ByTargetByIdentifierAttributesByAttributeOptionsByOptionData.parseAsync(data),
    responseValidator: async (data) => await zPatchV2ByTargetByIdentifierAttributesByAttributeOptionsByOptionResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/{target}/{identifier}/attributes/{attribute}/options/{option}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List statuses
 *
 * Lists all statuses for a particular status attribute on either an object or a list.
 *
 * Required scopes: `object_configuration:read`.
 */
export const getV2ByTargetByIdentifierAttributesByAttributeStatuses = <ThrowOnError extends boolean = false>(options: Options<GetV2ByTargetByIdentifierAttributesByAttributeStatusesData, ThrowOnError>) => (options.client ?? client).get<GetV2ByTargetByIdentifierAttributesByAttributeStatusesResponses, GetV2ByTargetByIdentifierAttributesByAttributeStatusesErrors, ThrowOnError>({
    requestValidator: async (data) => await zGetV2ByTargetByIdentifierAttributesByAttributeStatusesData.parseAsync(data),
    responseValidator: async (data) => await zGetV2ByTargetByIdentifierAttributesByAttributeStatusesResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/{target}/{identifier}/attributes/{attribute}/statuses',
    ...options
});

/**
 * Create a status
 *
 * Add a new status to a status attribute on either an object or a list.
 *
 * Required scopes: `object_configuration:read-write`.
 */
export const postV2ByTargetByIdentifierAttributesByAttributeStatuses = <ThrowOnError extends boolean = false>(options: Options<PostV2ByTargetByIdentifierAttributesByAttributeStatusesData, ThrowOnError>) => (options.client ?? client).post<PostV2ByTargetByIdentifierAttributesByAttributeStatusesResponses, PostV2ByTargetByIdentifierAttributesByAttributeStatusesErrors, ThrowOnError>({
    requestValidator: async (data) => await zPostV2ByTargetByIdentifierAttributesByAttributeStatusesData.parseAsync(data),
    responseValidator: async (data) => await zPostV2ByTargetByIdentifierAttributesByAttributeStatusesResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/{target}/{identifier}/attributes/{attribute}/statuses',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Update a status
 *
 * Update a status on an status attribute on either an object or a list.
 *
 * Required scopes: `object_configuration:read-write`.
 */
export const patchV2ByTargetByIdentifierAttributesByAttributeStatusesByStatus = <ThrowOnError extends boolean = false>(options: Options<PatchV2ByTargetByIdentifierAttributesByAttributeStatusesByStatusData, ThrowOnError>) => (options.client ?? client).patch<PatchV2ByTargetByIdentifierAttributesByAttributeStatusesByStatusResponses, PatchV2ByTargetByIdentifierAttributesByAttributeStatusesByStatusErrors, ThrowOnError>({
    requestValidator: async (data) => await zPatchV2ByTargetByIdentifierAttributesByAttributeStatusesByStatusData.parseAsync(data),
    responseValidator: async (data) => await zPatchV2ByTargetByIdentifierAttributesByAttributeStatusesByStatusResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/{target}/{identifier}/attributes/{attribute}/statuses/{status}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List records
 *
 * Lists people, company or other records, with the option to filter and sort results.
 *
 * Required scopes: `record_permission:read`, `object_configuration:read`.
 */
export const postV2ObjectsByObjectRecordsQuery = <ThrowOnError extends boolean = false>(options: Options<PostV2ObjectsByObjectRecordsQueryData, ThrowOnError>) => (options.client ?? client).post<PostV2ObjectsByObjectRecordsQueryResponses, PostV2ObjectsByObjectRecordsQueryErrors, ThrowOnError>({
    requestValidator: async (data) => await zPostV2ObjectsByObjectRecordsQueryData.parseAsync(data),
    responseValidator: async (data) => await zPostV2ObjectsByObjectRecordsQueryResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/objects/{object}/records/query',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Create a record
 *
 * Creates a new person, company or other record. This endpoint will throw on conflicts of unique attributes. If you would prefer to update records on conflicts, please use the [Assert record endpoint](/rest-api/endpoint-reference/records/assert-a-record) instead.
 *
 * Required scopes: `record_permission:read-write`, `object_configuration:read`.
 */
export const postV2ObjectsByObjectRecords = <ThrowOnError extends boolean = false>(options: Options<PostV2ObjectsByObjectRecordsData, ThrowOnError>) => (options.client ?? client).post<PostV2ObjectsByObjectRecordsResponses, PostV2ObjectsByObjectRecordsErrors, ThrowOnError>({
    requestValidator: async (data) => await zPostV2ObjectsByObjectRecordsData.parseAsync(data),
    responseValidator: async (data) => await zPostV2ObjectsByObjectRecordsResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/objects/{object}/records',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Assert a record
 *
 * Use this endpoint to create or update people, companies and other records. A matching attribute is used to search for existing records. If a record is found with the same value for the matching attribute, that record will be updated. If no record with the same value for the matching attribute is found, a new record will be created instead. If you would like to avoid matching, please use the [Create record endpoint](/rest-api/endpoint-reference/records/create-a-record).
 *
 * If the matching attribute is a multiselect attribute, new values will be added and existing values will not be deleted. For any other multiselect attribute, all values will be either created or deleted as necessary to match the list of supplied values.
 *
 * Required scopes: `record_permission:read-write`, `object_configuration:read`.
 */
export const putV2ObjectsByObjectRecords = <ThrowOnError extends boolean = false>(options: Options<PutV2ObjectsByObjectRecordsData, ThrowOnError>) => (options.client ?? client).put<PutV2ObjectsByObjectRecordsResponses, PutV2ObjectsByObjectRecordsErrors, ThrowOnError>({
    requestValidator: async (data) => await zPutV2ObjectsByObjectRecordsData.parseAsync(data),
    responseValidator: async (data) => await zPutV2ObjectsByObjectRecordsResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/objects/{object}/records',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a record
 *
 * Deletes a single record (e.g. a company or person) by ID.
 *
 * Required scopes: `object_configuration:read`, `record_permission:read-write`.
 */
export const deleteV2ObjectsByObjectRecordsByRecordId = <ThrowOnError extends boolean = false>(options: Options<DeleteV2ObjectsByObjectRecordsByRecordIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteV2ObjectsByObjectRecordsByRecordIdResponses, DeleteV2ObjectsByObjectRecordsByRecordIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zDeleteV2ObjectsByObjectRecordsByRecordIdData.parseAsync(data),
    responseValidator: async (data) => await zDeleteV2ObjectsByObjectRecordsByRecordIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/objects/{object}/records/{record_id}',
    ...options
});

/**
 * Get a record
 *
 * Gets a single person, company or other record by its `record_id`.
 *
 * Required scopes: `record_permission:read`, `object_configuration:read`.
 */
export const getV2ObjectsByObjectRecordsByRecordId = <ThrowOnError extends boolean = false>(options: Options<GetV2ObjectsByObjectRecordsByRecordIdData, ThrowOnError>) => (options.client ?? client).get<GetV2ObjectsByObjectRecordsByRecordIdResponses, GetV2ObjectsByObjectRecordsByRecordIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zGetV2ObjectsByObjectRecordsByRecordIdData.parseAsync(data),
    responseValidator: async (data) => await zGetV2ObjectsByObjectRecordsByRecordIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/objects/{object}/records/{record_id}',
    ...options
});

/**
 * Update a record (append multiselect values)
 *
 * Use this endpoint to update people, companies, and other records by `record_id`. If the update payload includes multiselect attributes, the values supplied will be created and prepended to the list of values that already exist (if any). Use the `PUT` endpoint to overwrite or remove multiselect attribute values.
 *
 * Required scopes: `record_permission:read-write`, `object_configuration:read`.
 */
export const patchV2ObjectsByObjectRecordsByRecordId = <ThrowOnError extends boolean = false>(options: Options<PatchV2ObjectsByObjectRecordsByRecordIdData, ThrowOnError>) => (options.client ?? client).patch<PatchV2ObjectsByObjectRecordsByRecordIdResponses, PatchV2ObjectsByObjectRecordsByRecordIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zPatchV2ObjectsByObjectRecordsByRecordIdData.parseAsync(data),
    responseValidator: async (data) => await zPatchV2ObjectsByObjectRecordsByRecordIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/objects/{object}/records/{record_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Update a record (overwrite multiselect values)
 *
 * Use this endpoint to update people, companies, and other records by `record_id`. If the update payload includes multiselect attributes, the values supplied will overwrite/remove the list of values that already exist (if any). Use the `PATCH` endpoint to append multiselect values without removing those that already exist.
 *
 * Required scopes: `record_permission:read-write`, `object_configuration:read`.
 */
export const putV2ObjectsByObjectRecordsByRecordId = <ThrowOnError extends boolean = false>(options: Options<PutV2ObjectsByObjectRecordsByRecordIdData, ThrowOnError>) => (options.client ?? client).put<PutV2ObjectsByObjectRecordsByRecordIdResponses, PutV2ObjectsByObjectRecordsByRecordIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zPutV2ObjectsByObjectRecordsByRecordIdData.parseAsync(data),
    responseValidator: async (data) => await zPutV2ObjectsByObjectRecordsByRecordIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/objects/{object}/records/{record_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List record attribute values
 *
 * Gets all values for a given attribute on a record. Historic values can be queried using the `show_historic` query param. Historic values cannot be queried on COMINT (Communication Intelligence) or enriched attributes and the endpoint will return a 400 error if this is attempted. Historic values are sorted from oldest to newest (by `active_from`). Some attributes are subject to billing status and will return an empty array of values if theworkspace being queried does not have the required billing flag enabled.
 *
 * Required scopes: `record_permission:read`, `object_configuration:read`.
 */
export const getV2ObjectsByObjectRecordsByRecordIdAttributesByAttributeValues = <ThrowOnError extends boolean = false>(options: Options<GetV2ObjectsByObjectRecordsByRecordIdAttributesByAttributeValuesData, ThrowOnError>) => (options.client ?? client).get<GetV2ObjectsByObjectRecordsByRecordIdAttributesByAttributeValuesResponses, GetV2ObjectsByObjectRecordsByRecordIdAttributesByAttributeValuesErrors, ThrowOnError>({
    requestValidator: async (data) => await zGetV2ObjectsByObjectRecordsByRecordIdAttributesByAttributeValuesData.parseAsync(data),
    responseValidator: async (data) => await zGetV2ObjectsByObjectRecordsByRecordIdAttributesByAttributeValuesResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/objects/{object}/records/{record_id}/attributes/{attribute}/values',
    ...options
});

/**
 * List record entries
 *
 * List all entries, across all lists, for which this record is the parent.
 *
 * Required scopes: `record_permission:read`, `object_configuration:read`, `list_entry:read`.
 */
export const getV2ObjectsByObjectRecordsByRecordIdEntries = <ThrowOnError extends boolean = false>(options: Options<GetV2ObjectsByObjectRecordsByRecordIdEntriesData, ThrowOnError>) => (options.client ?? client).get<GetV2ObjectsByObjectRecordsByRecordIdEntriesResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGetV2ObjectsByObjectRecordsByRecordIdEntriesData.parseAsync(data),
    responseValidator: async (data) => await zGetV2ObjectsByObjectRecordsByRecordIdEntriesResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/objects/{object}/records/{record_id}/entries',
    ...options
});

/**
 * Search records
 *
 * The search records endpoint provides a convenient way to fuzzy search for records across one or more objects.
 * The matching strategy employed in this endpoint follows the in-product strategy and will match names, domains, emails, phone numbers and social handles on people and companies, and labels on all other objects.
 * Please note, results returned from this endpoint are eventually consistent. For results which are guaranteed to be up to date, please use the record query endpoint instead.
 *
 * This endpoint is in beta. We will aim to avoid breaking changes, but small updates may be made as we roll out to more users.
 *
 * Required scopes: `record_permission:read`, `object_configuration:read`.
 */
export const postV2ObjectsRecordsSearch = <ThrowOnError extends boolean = false>(options: Options<PostV2ObjectsRecordsSearchData, ThrowOnError>) => (options.client ?? client).post<PostV2ObjectsRecordsSearchResponses, PostV2ObjectsRecordsSearchErrors, ThrowOnError>({
    requestValidator: async (data) => await zPostV2ObjectsRecordsSearchData.parseAsync(data),
    responseValidator: async (data) => await zPostV2ObjectsRecordsSearchResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/objects/records/search',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List all lists
 *
 * List all lists that your access token has access to. lists are returned in the order that they are sorted in the sidebar.
 *
 * Required scopes: `list_configuration:read`.
 */
export const getV2Lists = <ThrowOnError extends boolean = false>(options?: Options<GetV2ListsData, ThrowOnError>) => (options?.client ?? client).get<GetV2ListsResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGetV2ListsData.parseAsync(data),
    responseValidator: async (data) => await zGetV2ListsResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/lists',
    ...options
});

/**
 * Create a list
 *
 * Creates a new list.
 *
 * Once you have your list, add attributes to it using the [Create attribute](/rest-api/endpoint-reference/attributes/create-an-attribute) API, and add records to it using the [Add records to list](/rest-api/endpoint-reference/entries/create-an-entry-add-record-to-list) API.
 *
 * New lists must specify which records can be added with the `parent_object` parameter which accepts either an object slug or an object ID. Permissions for the list are controlled with the `workspace_access` and `workspace_member_access` parameters.
 *
 * Please note that new lists must have either `workspace_access` set to `"full-access"` or one or more element of `workspace_member_access` with a `"full-access"` level. It is also possible to receive a `403` billing error if your workspace is not on a plan that supports either advanced workspace or workspace member-level access for lists.
 *
 * Required scopes: `list_configuration:read-write`.
 */
export const postV2Lists = <ThrowOnError extends boolean = false>(options: Options<PostV2ListsData, ThrowOnError>) => (options.client ?? client).post<PostV2ListsResponses, PostV2ListsErrors, ThrowOnError>({
    requestValidator: async (data) => await zPostV2ListsData.parseAsync(data),
    responseValidator: async (data) => await zPostV2ListsResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/lists',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get a list
 *
 * Gets a single list in your workspace that your access token has access to.
 *
 * Required scopes: `list_configuration:read`.
 */
export const getV2ListsByList = <ThrowOnError extends boolean = false>(options: Options<GetV2ListsByListData, ThrowOnError>) => (options.client ?? client).get<GetV2ListsByListResponses, GetV2ListsByListErrors, ThrowOnError>({
    requestValidator: async (data) => await zGetV2ListsByListData.parseAsync(data),
    responseValidator: async (data) => await zGetV2ListsByListResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/lists/{list}',
    ...options
});

/**
 * Update a list
 *
 * Updates an existing list. Permissions for the list are controlled with the `workspace_access` and `workspace_member_access` parameters. Please note that lists must have either `workspace_access` set to `"full-access"` or one or more element of `workspace_member_access` with a `"full-access"` level. It is also possible to receive a `403` billing error if your workspace is not on a plan that supports either advanced workspace or workspace member level access for lists. Changing the parent object of a list is not possible through the API as it can have unintended side-effects that should be considered carefully. If you wish to carry out a parent object change you should do so through the UI.
 *
 * Required scopes: `list_configuration:read-write`.
 */
export const patchV2ListsByList = <ThrowOnError extends boolean = false>(options: Options<PatchV2ListsByListData, ThrowOnError>) => (options.client ?? client).patch<PatchV2ListsByListResponses, PatchV2ListsByListErrors, ThrowOnError>({
    requestValidator: async (data) => await zPatchV2ListsByListData.parseAsync(data),
    responseValidator: async (data) => await zPatchV2ListsByListResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/lists/{list}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List entries
 *
 * Lists entries in a given list, with the option to filter and sort results.
 *
 * Required scopes: `list_entry:read`, `list_configuration:read`.
 */
export const postV2ListsByListEntriesQuery = <ThrowOnError extends boolean = false>(options: Options<PostV2ListsByListEntriesQueryData, ThrowOnError>) => (options.client ?? client).post<PostV2ListsByListEntriesQueryResponses, PostV2ListsByListEntriesQueryErrors, ThrowOnError>({
    requestValidator: async (data) => await zPostV2ListsByListEntriesQueryData.parseAsync(data),
    responseValidator: async (data) => await zPostV2ListsByListEntriesQueryResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/lists/{list}/entries/query',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Create an entry (add record to list)
 *
 * Adds a record to a list as a new list entry. This endpoint will throw on conflicts of unique attributes. Multiple list entries are allowed for the same parent record
 *
 * Required scopes: `list_entry:read-write`, `list_configuration:read`.
 */
export const postV2ListsByListEntries = <ThrowOnError extends boolean = false>(options: Options<PostV2ListsByListEntriesData, ThrowOnError>) => (options.client ?? client).post<PostV2ListsByListEntriesResponses, PostV2ListsByListEntriesErrors, ThrowOnError>({
    requestValidator: async (data) => await zPostV2ListsByListEntriesData.parseAsync(data),
    responseValidator: async (data) => await zPostV2ListsByListEntriesResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/lists/{list}/entries',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Assert a list entry by parent
 *
 * Use this endpoint to create or update a list entry for a given parent record. If an entry with the specified parent record is found, that entry will be updated. If no such entry is found, a new entry will be created instead. If there are multiple entries with the same parent record, this endpoint with return the "MULTIPLE_MATCH_RESULTS" error. When writing to multi-select attributes, all values will be either created or deleted as necessary to match the list of values supplied in the request body.
 *
 * Required scopes: `list_entry:read-write`, `list_configuration:read`.
 */
export const putV2ListsByListEntries = <ThrowOnError extends boolean = false>(options: Options<PutV2ListsByListEntriesData, ThrowOnError>) => (options.client ?? client).put<PutV2ListsByListEntriesResponses, PutV2ListsByListEntriesErrors, ThrowOnError>({
    requestValidator: async (data) => await zPutV2ListsByListEntriesData.parseAsync(data),
    responseValidator: async (data) => await zPutV2ListsByListEntriesResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/lists/{list}/entries',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a list entry
 *
 * Deletes a single list entry by its `entry_id`.
 *
 * Required scopes: `list_entry:read-write`, `list_configuration:read`.
 */
export const deleteV2ListsByListEntriesByEntryId = <ThrowOnError extends boolean = false>(options: Options<DeleteV2ListsByListEntriesByEntryIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteV2ListsByListEntriesByEntryIdResponses, DeleteV2ListsByListEntriesByEntryIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zDeleteV2ListsByListEntriesByEntryIdData.parseAsync(data),
    responseValidator: async (data) => await zDeleteV2ListsByListEntriesByEntryIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/lists/{list}/entries/{entry_id}',
    ...options
});

/**
 * Get a list entry
 *
 * Gets a single list entry by its `entry_id`.
 *
 * Required scopes: `list_entry:read`, `list_configuration:read`.
 */
export const getV2ListsByListEntriesByEntryId = <ThrowOnError extends boolean = false>(options: Options<GetV2ListsByListEntriesByEntryIdData, ThrowOnError>) => (options.client ?? client).get<GetV2ListsByListEntriesByEntryIdResponses, GetV2ListsByListEntriesByEntryIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zGetV2ListsByListEntriesByEntryIdData.parseAsync(data),
    responseValidator: async (data) => await zGetV2ListsByListEntriesByEntryIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/lists/{list}/entries/{entry_id}',
    ...options
});

/**
 * Update a list entry (append multiselect values)
 *
 * Use this endpoint to update list entries by `entry_id`. If the update payload includes multiselect attributes, the values supplied will be created and prepended to the list of values that already exist (if any). Use the `PUT` endpoint to overwrite or remove multiselect attribute values.
 *
 * Required scopes: `list_entry:read-write`, `list_configuration:read`.
 */
export const patchV2ListsByListEntriesByEntryId = <ThrowOnError extends boolean = false>(options: Options<PatchV2ListsByListEntriesByEntryIdData, ThrowOnError>) => (options.client ?? client).patch<PatchV2ListsByListEntriesByEntryIdResponses, PatchV2ListsByListEntriesByEntryIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zPatchV2ListsByListEntriesByEntryIdData.parseAsync(data),
    responseValidator: async (data) => await zPatchV2ListsByListEntriesByEntryIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/lists/{list}/entries/{entry_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Update a list entry (overwrite multiselect values)
 *
 * Use this endpoint to update list entries by `entry_id`. If the update payload includes multiselect attributes, the values supplied will overwrite/remove the list of values that already exist (if any). Use the `PATCH` endpoint to add multiselect attribute values without removing those value that already exist.
 *
 * Required scopes: `list_entry:read-write`, `list_configuration:read`.
 */
export const putV2ListsByListEntriesByEntryId = <ThrowOnError extends boolean = false>(options: Options<PutV2ListsByListEntriesByEntryIdData, ThrowOnError>) => (options.client ?? client).put<PutV2ListsByListEntriesByEntryIdResponses, PutV2ListsByListEntriesByEntryIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zPutV2ListsByListEntriesByEntryIdData.parseAsync(data),
    responseValidator: async (data) => await zPutV2ListsByListEntriesByEntryIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/lists/{list}/entries/{entry_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List attribute values for a list entry
 *
 * Gets all values for a given attribute on a list entry. This endpoint has the ability to return all historic values using the `show_historic` query param. Historic values are sorted from oldest to newest (by `active_from`).
 *
 * Required scopes: `list_entry:read`, `list_configuration:read`.
 */
export const getV2ListsByListEntriesByEntryIdAttributesByAttributeValues = <ThrowOnError extends boolean = false>(options: Options<GetV2ListsByListEntriesByEntryIdAttributesByAttributeValuesData, ThrowOnError>) => (options.client ?? client).get<GetV2ListsByListEntriesByEntryIdAttributesByAttributeValuesResponses, GetV2ListsByListEntriesByEntryIdAttributesByAttributeValuesErrors, ThrowOnError>({
    requestValidator: async (data) => await zGetV2ListsByListEntriesByEntryIdAttributesByAttributeValuesData.parseAsync(data),
    responseValidator: async (data) => await zGetV2ListsByListEntriesByEntryIdAttributesByAttributeValuesResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/lists/{list}/entries/{entry_id}/attributes/{attribute}/values',
    ...options
});

/**
 * List workspace members
 *
 * Lists all workspace members in the workspace.
 *
 * Required scopes: `user_management:read`.
 */
export const getV2WorkspaceMembers = <ThrowOnError extends boolean = false>(options?: Options<GetV2WorkspaceMembersData, ThrowOnError>) => (options?.client ?? client).get<GetV2WorkspaceMembersResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGetV2WorkspaceMembersData.parseAsync(data),
    responseValidator: async (data) => await zGetV2WorkspaceMembersResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/workspace_members',
    ...options
});

/**
 * Get a workspace member
 *
 * Gets a single workspace member by ID.
 *
 * Required scopes: `user_management:read`.
 */
export const getV2WorkspaceMembersByWorkspaceMemberId = <ThrowOnError extends boolean = false>(options: Options<GetV2WorkspaceMembersByWorkspaceMemberIdData, ThrowOnError>) => (options.client ?? client).get<GetV2WorkspaceMembersByWorkspaceMemberIdResponses, GetV2WorkspaceMembersByWorkspaceMemberIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zGetV2WorkspaceMembersByWorkspaceMemberIdData.parseAsync(data),
    responseValidator: async (data) => await zGetV2WorkspaceMembersByWorkspaceMemberIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/workspace_members/{workspace_member_id}',
    ...options
});

/**
 * List notes
 *
 * List notes for all records or for a specific record.
 *
 * Required scopes: `note:read`, `object_configuration:read`, `record_permission:read`.
 */
export const getV2Notes = <ThrowOnError extends boolean = false>(options?: Options<GetV2NotesData, ThrowOnError>) => (options?.client ?? client).get<GetV2NotesResponses, GetV2NotesErrors, ThrowOnError>({
    requestValidator: async (data) => await zGetV2NotesData.parseAsync(data),
    responseValidator: async (data) => await zGetV2NotesResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/notes',
    ...options
});

/**
 * Create a note
 *
 * Creates a new note for a given record.
 *
 * Required scopes: `note:read-write`, `object_configuration:read`, `record_permission:read`.
 */
export const postV2Notes = <ThrowOnError extends boolean = false>(options: Options<PostV2NotesData, ThrowOnError>) => (options.client ?? client).post<PostV2NotesResponses, PostV2NotesErrors, ThrowOnError>({
    requestValidator: async (data) => await zPostV2NotesData.parseAsync(data),
    responseValidator: async (data) => await zPostV2NotesResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/notes',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a note
 *
 * Delete a single note by ID.
 *
 * Required scopes: `note:read-write`.
 */
export const deleteV2NotesByNoteId = <ThrowOnError extends boolean = false>(options: Options<DeleteV2NotesByNoteIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteV2NotesByNoteIdResponses, DeleteV2NotesByNoteIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zDeleteV2NotesByNoteIdData.parseAsync(data),
    responseValidator: async (data) => await zDeleteV2NotesByNoteIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/notes/{note_id}',
    ...options
});

/**
 * Get a note
 *
 * Get a single note by ID.
 *
 * Required scopes: `note:read`, `object_configuration:read`, `record_permission:read`.
 */
export const getV2NotesByNoteId = <ThrowOnError extends boolean = false>(options: Options<GetV2NotesByNoteIdData, ThrowOnError>) => (options.client ?? client).get<GetV2NotesByNoteIdResponses, GetV2NotesByNoteIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zGetV2NotesByNoteIdData.parseAsync(data),
    responseValidator: async (data) => await zGetV2NotesByNoteIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/notes/{note_id}',
    ...options
});

/**
 * List tasks
 *
 * List all tasks. Results are sorted by creation date, from oldest to newest.
 *
 * Required scopes: `task:read`, `object_configuration:read`, `record_permission:read`, `user_management:read`.
 */
export const getV2Tasks = <ThrowOnError extends boolean = false>(options?: Options<GetV2TasksData, ThrowOnError>) => (options?.client ?? client).get<GetV2TasksResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGetV2TasksData.parseAsync(data),
    responseValidator: async (data) => await zGetV2TasksResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/tasks',
    ...options
});

/**
 * Create a task
 *
 * Creates a new task.
 *
 * At present, tasks can only be created from plaintext without record reference formatting.
 *
 * Required scopes: `task:read-write`, `object_configuration:read`, `record_permission:read`, `user_management:read`.
 */
export const postV2Tasks = <ThrowOnError extends boolean = false>(options: Options<PostV2TasksData, ThrowOnError>) => (options.client ?? client).post<PostV2TasksResponses, PostV2TasksErrors, ThrowOnError>({
    requestValidator: async (data) => await zPostV2TasksData.parseAsync(data),
    responseValidator: async (data) => await zPostV2TasksResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/tasks',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a task
 *
 * Delete a task by ID.
 *
 * Required scopes: `task:read-write`.
 */
export const deleteV2TasksByTaskId = <ThrowOnError extends boolean = false>(options: Options<DeleteV2TasksByTaskIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteV2TasksByTaskIdResponses, DeleteV2TasksByTaskIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zDeleteV2TasksByTaskIdData.parseAsync(data),
    responseValidator: async (data) => await zDeleteV2TasksByTaskIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/tasks/{task_id}',
    ...options
});

/**
 * Get a task
 *
 * Get a single task by ID.
 *
 * Required scopes: `task:read`, `object_configuration:read`, `record_permission:read`, `user_management:read`.
 */
export const getV2TasksByTaskId = <ThrowOnError extends boolean = false>(options: Options<GetV2TasksByTaskIdData, ThrowOnError>) => (options.client ?? client).get<GetV2TasksByTaskIdResponses, GetV2TasksByTaskIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zGetV2TasksByTaskIdData.parseAsync(data),
    responseValidator: async (data) => await zGetV2TasksByTaskIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/tasks/{task_id}',
    ...options
});

/**
 * Update a task
 *
 * Updates an existing task by `task_id`. At present, only the `deadline_at`, `is_completed`, `linked_records`, and `assignees` fields can be updated.
 *
 * Required scopes: `task:read-write`, `object_configuration:read`, `record_permission:read`, `user_management:read`.
 */
export const patchV2TasksByTaskId = <ThrowOnError extends boolean = false>(options: Options<PatchV2TasksByTaskIdData, ThrowOnError>) => (options.client ?? client).patch<PatchV2TasksByTaskIdResponses, PatchV2TasksByTaskIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zPatchV2TasksByTaskIdData.parseAsync(data),
    responseValidator: async (data) => await zPatchV2TasksByTaskIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/tasks/{task_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * List threads
 *
 * List threads of comments on a record or list entry.
 *
 * To view threads on records, you will need the `object_configuration:read` and `record_permission:read` scopes.
 *
 * To view threads on list entries, you will need the `list_configuration:read` and `list_entry:read` scopes.
 *
 * Required scopes: `comment:read`.
 */
export const getV2Threads = <ThrowOnError extends boolean = false>(options?: Options<GetV2ThreadsData, ThrowOnError>) => (options?.client ?? client).get<GetV2ThreadsResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGetV2ThreadsData.parseAsync(data),
    responseValidator: async (data) => await zGetV2ThreadsResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/threads',
    ...options
});

/**
 * Get a thread
 *
 * Get all comments in a thread.
 *
 * To view threads on records, you will need the `object_configuration:read` and `record_permission:read` scopes.
 *
 * To view threads on list entries, you will need the `list_configuration:read` and `list_entry:read` scopes.
 *
 * Required scopes: `comment:read`.
 */
export const getV2ThreadsByThreadId = <ThrowOnError extends boolean = false>(options: Options<GetV2ThreadsByThreadIdData, ThrowOnError>) => (options.client ?? client).get<GetV2ThreadsByThreadIdResponses, GetV2ThreadsByThreadIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zGetV2ThreadsByThreadIdData.parseAsync(data),
    responseValidator: async (data) => await zGetV2ThreadsByThreadIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/threads/{thread_id}',
    ...options
});

/**
 * Create a comment
 *
 * Creates a new comment related to an existing thread, record or entry.
 *
 * To create comments on records, you will need the `object_configuration:read` and `record_permission:read` scopes.
 *
 * To create comments on list entries, you will need the `list_configuration:read` and `list_entry:read` scopes.
 *
 * Required scopes: `comment:read-write`.
 */
export const postV2Comments = <ThrowOnError extends boolean = false>(options: Options<PostV2CommentsData, ThrowOnError>) => (options.client ?? client).post<PostV2CommentsResponses, PostV2CommentsErrors, ThrowOnError>({
    requestValidator: async (data) => await zPostV2CommentsData.parseAsync(data),
    responseValidator: async (data) => await zPostV2CommentsResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/comments',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a comment
 *
 * Deletes a comment by ID. If deleting a comment at the head of a thread, all messages in the thread are also deleted.
 *
 * Required scopes: `comment:read-write`.
 */
export const deleteV2CommentsByCommentId = <ThrowOnError extends boolean = false>(options: Options<DeleteV2CommentsByCommentIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteV2CommentsByCommentIdResponses, DeleteV2CommentsByCommentIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zDeleteV2CommentsByCommentIdData.parseAsync(data),
    responseValidator: async (data) => await zDeleteV2CommentsByCommentIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/comments/{comment_id}',
    ...options
});

/**
 * Get a comment
 *
 * Get a single comment by ID.
 *
 * To view comments on records, you will need the `object_configuration:read` and `record_permission:read` scopes.
 *
 * To view comments on list entries, you will need the `list_configuration:read` and `list_entry:read` scopes.
 *
 * Required scopes: `comment:read`.
 */
export const getV2CommentsByCommentId = <ThrowOnError extends boolean = false>(options: Options<GetV2CommentsByCommentIdData, ThrowOnError>) => (options.client ?? client).get<GetV2CommentsByCommentIdResponses, GetV2CommentsByCommentIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zGetV2CommentsByCommentIdData.parseAsync(data),
    responseValidator: async (data) => await zGetV2CommentsByCommentIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/comments/{comment_id}',
    ...options
});

/**
 * List meetings
 *
 * Lists all meetings in the workspace using a deterministic sort order.
 *
 * This endpoint is in beta. We will aim to avoid breaking changes, but small updates may be made as we roll out to more users.
 *
 * Required scopes: `meeting:read`, `record_permission:read`.
 */
export const getV2Meetings = <ThrowOnError extends boolean = false>(options?: Options<GetV2MeetingsData, ThrowOnError>) => (options?.client ?? client).get<GetV2MeetingsResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGetV2MeetingsData.parseAsync(data),
    responseValidator: async (data) => await zGetV2MeetingsResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/meetings',
    ...options
});

/**
 * Find or create a meeting
 *
 * Finds an existing meeting or creates a new one if it doesn't yet exist. [Please see here](/rest-api/guides/syncing-meetings) for a full guide on syncing meetings to Attio.
 *
 * This endpoint is in alpha and may be subject to breaking changes as we gather feedback.
 *
 * Required scopes: `meeting:read-write`, `record_permission:read`.
 */
export const postV2Meetings = <ThrowOnError extends boolean = false>(options: Options<PostV2MeetingsData, ThrowOnError>) => (options.client ?? client).post<PostV2MeetingsResponses, PostV2MeetingsErrors, ThrowOnError>({
    requestValidator: async (data) => await zPostV2MeetingsData.parseAsync(data),
    responseValidator: async (data) => await zPostV2MeetingsResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/meetings',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Get a meeting
 *
 * Get a single meeting by ID.
 *
 * This endpoint is in beta. We will aim to avoid breaking changes, but small updates may be made as we roll out to more users.
 *
 * Required scopes: `meeting:read`, `record_permission:read`.
 */
export const getV2MeetingsByMeetingId = <ThrowOnError extends boolean = false>(options: Options<GetV2MeetingsByMeetingIdData, ThrowOnError>) => (options.client ?? client).get<GetV2MeetingsByMeetingIdResponses, GetV2MeetingsByMeetingIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zGetV2MeetingsByMeetingIdData.parseAsync(data),
    responseValidator: async (data) => await zGetV2MeetingsByMeetingIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/meetings/{meeting_id}',
    ...options
});

/**
 * List call recordings
 *
 * List all call recordings for a meeting.
 *
 * This endpoint is in beta. We will aim to avoid breaking changes, but small updates may be made as we roll out to more users.
 *
 * Required scopes: `meeting:read`, `call_recording:read`.
 */
export const getV2MeetingsByMeetingIdCallRecordings = <ThrowOnError extends boolean = false>(options: Options<GetV2MeetingsByMeetingIdCallRecordingsData, ThrowOnError>) => (options.client ?? client).get<GetV2MeetingsByMeetingIdCallRecordingsResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGetV2MeetingsByMeetingIdCallRecordingsData.parseAsync(data),
    responseValidator: async (data) => await zGetV2MeetingsByMeetingIdCallRecordingsResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/meetings/{meeting_id}/call_recordings',
    ...options
});

/**
 * Create call recording
 *
 * Create a call recording for a meeting. This endpoint is rate limited to 1 request per second.
 *
 * This endpoint is in alpha and may be subject to breaking changes as we gather feedback.
 *
 * Required scopes: `meeting:read`, `call_recording:read-write`.
 */
export const postV2MeetingsByMeetingIdCallRecordings = <ThrowOnError extends boolean = false>(options: Options<PostV2MeetingsByMeetingIdCallRecordingsData, ThrowOnError>) => (options.client ?? client).post<PostV2MeetingsByMeetingIdCallRecordingsResponses, PostV2MeetingsByMeetingIdCallRecordingsErrors, ThrowOnError>({
    requestValidator: async (data) => await zPostV2MeetingsByMeetingIdCallRecordingsData.parseAsync(data),
    responseValidator: async (data) => await zPostV2MeetingsByMeetingIdCallRecordingsResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/meetings/{meeting_id}/call_recordings',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete call recording
 *
 * Deletes the specified call recording. This will remove the call recording and all associated data.
 *
 * This endpoint is in alpha and may be subject to breaking changes as we gather feedback.
 *
 * Required scopes: `meeting:read`, `call_recording:read-write`.
 */
export const deleteV2MeetingsByMeetingIdCallRecordingsByCallRecordingId = <ThrowOnError extends boolean = false>(options: Options<DeleteV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdResponses, DeleteV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zDeleteV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdData.parseAsync(data),
    responseValidator: async (data) => await zDeleteV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/meetings/{meeting_id}/call_recordings/{call_recording_id}',
    ...options
});

/**
 * Get call recording
 *
 * Get a single call recording by ID.
 *
 * This endpoint is in beta. We will aim to avoid breaking changes, but small updates may be made as we roll out to more users.
 *
 * Required scopes: `meeting:read`, `call_recording:read`.
 */
export const getV2MeetingsByMeetingIdCallRecordingsByCallRecordingId = <ThrowOnError extends boolean = false>(options: Options<GetV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdData, ThrowOnError>) => (options.client ?? client).get<GetV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdResponses, GetV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zGetV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdData.parseAsync(data),
    responseValidator: async (data) => await zGetV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/meetings/{meeting_id}/call_recordings/{call_recording_id}',
    ...options
});

/**
 * Get call transcript
 *
 * Get the transcript for a call recording.
 *
 * This endpoint is in beta. We will aim to avoid breaking changes, but small updates may be made as we roll out to more users.
 *
 * Required scopes: `meeting:read`, `call_recording:read`.
 */
export const getV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdTranscript = <ThrowOnError extends boolean = false>(options: Options<GetV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdTranscriptData, ThrowOnError>) => (options.client ?? client).get<GetV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdTranscriptResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGetV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdTranscriptData.parseAsync(data),
    responseValidator: async (data) => await zGetV2MeetingsByMeetingIdCallRecordingsByCallRecordingIdTranscriptResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/meetings/{meeting_id}/call_recordings/{call_recording_id}/transcript',
    ...options
});

/**
 * List SCIM schemas
 *
 * Lists the SCIM schemas supported by this service provider.
 *
 * Required scopes: `scim_management:read-write`.
 */
export const getScimV2Schemas = <ThrowOnError extends boolean = false>(options?: Options<GetScimV2SchemasData, ThrowOnError>) => (options?.client ?? client).get<GetScimV2SchemasResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGetScimV2SchemasData.parseAsync(data),
    responseValidator: async (data) => await zGetScimV2SchemasResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/scim/v2/Schemas',
    ...options
});

/**
 * List webhooks
 *
 * Get all of the webhooks in your workspace.
 *
 * Required scopes: `webhook:read`.
 */
export const getV2Webhooks = <ThrowOnError extends boolean = false>(options?: Options<GetV2WebhooksData, ThrowOnError>) => (options?.client ?? client).get<GetV2WebhooksResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGetV2WebhooksData.parseAsync(data),
    responseValidator: async (data) => await zGetV2WebhooksResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/webhooks',
    ...options
});

/**
 * Create a webhook
 *
 * Create a webhook and associated subscriptions.
 *
 * Required scopes: `webhook:read-write`.
 */
export const postV2Webhooks = <ThrowOnError extends boolean = false>(options: Options<PostV2WebhooksData, ThrowOnError>) => (options.client ?? client).post<PostV2WebhooksResponses, PostV2WebhooksErrors, ThrowOnError>({
    requestValidator: async (data) => await zPostV2WebhooksData.parseAsync(data),
    responseValidator: async (data) => await zPostV2WebhooksResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/webhooks',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Delete a webhook
 *
 * Delete a webhook by ID.
 *
 * Required scopes: `webhook:read-write`.
 */
export const deleteV2WebhooksByWebhookId = <ThrowOnError extends boolean = false>(options: Options<DeleteV2WebhooksByWebhookIdData, ThrowOnError>) => (options.client ?? client).delete<DeleteV2WebhooksByWebhookIdResponses, DeleteV2WebhooksByWebhookIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zDeleteV2WebhooksByWebhookIdData.parseAsync(data),
    responseValidator: async (data) => await zDeleteV2WebhooksByWebhookIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/webhooks/{webhook_id}',
    ...options
});

/**
 * Get a webhook
 *
 * Get a single webhook.
 *
 * Required scopes: `webhook:read`.
 */
export const getV2WebhooksByWebhookId = <ThrowOnError extends boolean = false>(options: Options<GetV2WebhooksByWebhookIdData, ThrowOnError>) => (options.client ?? client).get<GetV2WebhooksByWebhookIdResponses, GetV2WebhooksByWebhookIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zGetV2WebhooksByWebhookIdData.parseAsync(data),
    responseValidator: async (data) => await zGetV2WebhooksByWebhookIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/webhooks/{webhook_id}',
    ...options
});

/**
 * Update a webhook
 *
 * Update a webhook and associated subscriptions.
 *
 * Required scopes: `webhook:read-write`.
 */
export const patchV2WebhooksByWebhookId = <ThrowOnError extends boolean = false>(options: Options<PatchV2WebhooksByWebhookIdData, ThrowOnError>) => (options.client ?? client).patch<PatchV2WebhooksByWebhookIdResponses, PatchV2WebhooksByWebhookIdErrors, ThrowOnError>({
    requestValidator: async (data) => await zPatchV2WebhooksByWebhookIdData.parseAsync(data),
    responseValidator: async (data) => await zPatchV2WebhooksByWebhookIdResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/webhooks/{webhook_id}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

/**
 * Identify
 *
 * Identify the current access token, the workspace it is linked to, and any permissions it has.
 */
export const getV2Self = <ThrowOnError extends boolean = false>(options?: Options<GetV2SelfData, ThrowOnError>) => (options?.client ?? client).get<GetV2SelfResponses, unknown, ThrowOnError>({
    requestValidator: async (data) => await zGetV2SelfData.parseAsync(data),
    responseValidator: async (data) => await zGetV2SelfResponse.parseAsync(data),
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v2/self',
    ...options
});
